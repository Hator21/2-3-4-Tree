
test all methods on empty list

test all methods on root as tree

List cases where my remove works

Mention clrs

RemoveHack

Default comparator



						//So merge them
						
						//Check for null XXX
						//Merge c onto left
						if (leftSibling != null) {
							
							T k1 = node.removeElem(indexC-1); //Remove proper key from node, shift elems
							
							//Remove what should be c
							TwoFourNode<T> tmp = node.removeEdge(indexC);
							if ( tmp != c)
								throw new TwoFourNodeException("Issue!");
							
							//Shift edges left to fill space on node
							int j;
							for (j = indexC; j < 4 - 1; j++  ) { //<3 because j+1 = 3 at a certain point
								TwoFourNode<T> tmp2 = node.getChild(j + 1); 
								node.createEdge(j, tmp2);
							}
							node.createEdge(j, null); //Last child index  becomes null;
							
							
							//Add k1 to leftSibling;
							int inew = leftSibling.addNewElem(k1); //Add k1 to ls, should be last, returns index. Need to shift children
							//C only has one element, add it to left sibling
							inew = leftSibling.addNewElem(c.getElem(0));
							
							leftSibling.createEdge(2,c.getChild(0)); //Add first child of c
							leftSibling.createEdge(3,c.getChild(1)); //Add last child of c as last child of left sib
							
							//If parent collapsed
							if (node.howManyElems() <= 0) {
								TwoFourNode<T> parent = node.parent();
								
								//Find index
								int l;
								for (l = 0; l < 4-1; l++) {
									if(node == parent.getChild(l)) {
										break;
									}
								}
								if (l == 4) 
									throw new TwoFourNodeException("Issue!");
								
								//left sibling is new root
								parent.createEdge(l, leftSibling);
							}
							//We'll be recurrning on c
							c = leftSibling;
						}
						//Merge with right sibling
						//Right sibling
						else {
							
							//Merge right sibling ONTO c
							
							T k1 = node.removeElem(indexC);
							c.addNewElem(k1);
							
							//Shift edges left to fill space on node
							int j;
							
							//Start from link to rightsibling and clobber it
							for (j = indexC + 1; j < 4 - 1; j++  ) { //<3 because j+1 = 3 at a certain point
								TwoFourNode<T> tmp2 = node.getChild(j + 1); 
								node.createEdge(j, tmp2);
							}
							node.createEdge(j, null); //Last child index  becomes null;
							
							c.createEdge(2,rightSibling.getChild(0));
							c.createEdge(3,rightSibling.getChild(1));
							
							//If parent collapsed
							if (node.howManyElems() <= 0) {
								TwoFourNode<T> parent = node.parent();
								
								//Find index
								int l;
								for (l = 0; l < 4-1; l++) {
									if(node == parent.getChild(l)) {
										break;
									}
								}
								if (l == 4) 
									throw new TwoFourNodeException("Issue!");
								
								//left sibling is new root
								parent.createEdge(l, c);
							}
							
						} //End right sibling
							
							
							
							
					}//End bothoth smaller